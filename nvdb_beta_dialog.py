import sys
nvdblibrary = 'C:/DATA/nvdb-test/nvdbapi-V3-master'
# nvdblibrary = 'C:\Users\<DITT BRUKERNAVN>\Downloads\\nvdbapi-V3-master\\nvdbapi-V3-master'
# nvdblibrary = '/home/jan/Documents/jobb/nvdbapi-V3'


## Hvis vi ikke klarer å importere nvdbapiv3 så prøver vi å føye
## mappen nvdblibrary til søkestien. 
try: 
    import nvdbapiv3
except ModuleNotFoundError:
    print( "Fant ikke nvdbapiv3 i sys.path, legger til mappen", nvdblibrary)
    sys.path.append( nvdblibrary ) 
    
    try: 
        import nvdbapiv3
    except ModuleNotFoundError as e:
        print( "\nImport av nvdbapiv3 feiler for", nvdblibrary  )
        raise ModuleNotFoundError( "==> Variabel nvdblibrary skal peke til mappen https://github.com/LtGlahn/nvdbapi-V3  <==" )
            
    else: 
        print( "SUKSESS - kan importere nvdbapiv3 etter at vi la til", nvdblibrary, "i sys.path" )
else:
    print( "HURRA - vi kan importere nvdbapiv3 " ) 


# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CustomNVDBDialog
                                 A QGIS plugin
 Tesgtint VNDB Data fetching data from backend
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-02
        git sha              : $Format:%H$
        copyright            : (C) 2023 by vegvesen
        email                : alexander.casado@vegvesen.no
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from nvdbapiv3 import nvdbFagdata, nvdbVegnett
from nvdbapiV3qgis3 import  nvdb2kart, nvdbsok2qgis, url2kart, nvdb2kartListe

from PyQt5.QtWidgets import QTableWidgetItem, QAbstractItemView

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.utils import iface
from qgis.core import QgsProject

from PyQt5.QtWidgets import QCompleter, QVBoxLayout, QLabel

#========================================
#includes need it for development

import os
import json
import requests

#=================================================================================
#classess

class AreaGeoDataParser:
    def __init__(self):
        pass
        
    @classmethod    
    def counties(self):
        response = requests.get('https://nvdbapiles-v3.atlas.vegvesen.no/omrader/fylker.json')
        data = ''
        if response.status_code:
            data = response.text
            
            parsed = json.loads(data)
            dict = {}
            
            for iteration in parsed:
                dict[iteration['navn']] = iteration['nummer']
                
            return dict
            
    @classmethod    
    def communities(self):
        response = requests.get('https://nvdbapiles-v3.atlas.vegvesen.no/omrader/kommuner.json')
        data = ''
        if response.status_code:
            data = response.text
            
            parsed = json.loads(data)
            dict = {}
            self.communitiesInCounties = {}
            
            for iteration in parsed:
                dict[iteration['navn']] = iteration['nummer']
                self.communitiesInCounties[iteration['navn']] = iteration['fylke']
                
            return dict
            
    @classmethod
    def fetchAllNvdbObjects(self):
        objectTypesEndPoint = "https://nvdbapiles-v3.atlas.vegvesen.no/vegobjekttyper.json"
        
        response = requests.get(objectTypesEndPoint)
        
        data = response.text
        
        parsedData = json.loads(data)
        
        dict = {}
        
        for item in parsedData:
            dict[item['navn']] = item['id']
        
        return dict
        
    @classmethod    
    def egenskaper(self, datakatalogId):
        endpointObjectType = "https://nvdbapiles-v3.atlas.vegvesen.no/vegobjekttyper/" + str(datakatalogId)
        
        data = requests.get(endpointObjectType)
        
        raw = data.text
        
        parsed = json.loads(raw)
        
        egenskapType = parsed['egenskapstyper']
        listOfNames = {}
        
        for item in egenskapType:
            listOfNames[item['navn']] = item['id']
                
        return listOfNames
        
    @classmethod
    def especificEgenskaper(self, datakatalogId, egenskapName):
        endpointObjectType = "https://nvdbapiles-v3.atlas.vegvesen.no/vegobjekttyper/"+str(datakatalogId)
            
        data = requests.get(endpointObjectType)
            
        raw = data.text
            
        parsed = json.loads(raw)
            
        egenskapType = parsed['egenskapstyper']
        listOfEspecificProps = {}
            
        for item in egenskapType:
            if item['navn'] == egenskapName:
                for name, props in item.items():
                    if name == 'datatype':
                        self.especificEgenskapDataType = props
                        
                    if name == 'tillatte_verdier':
                        for especificProp in props:
                           listOfEspecificProps[especificProp['verdi']] = especificProp['id']
                    
        return listOfEspecificProps
    
    @classmethod
    def egenskapDataType(self):
        return self.especificEgenskapDataType

#end of classess

#================================================================================
# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NvdbBetaProductionDialog
                                 A QGIS plugin
 nvdb plugin to filtrate and show objects belonging to the norwegian roads
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-05-12
        git sha              : $Format:%H$
        copyright            : (C) 2023 by SVV
        email                : alexander.casado@vegvesen.no
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'nvdb_beta_dialog_base.ui'))


class NvdbBetaProductionDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(NvdbBetaProductionDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
#        development starts here
#        setting up all data need it for starting up
        
#        making filter edit box unabled when program start
        self.filterByLineEdit.setEnabled(False)
        
#        setting up  combobox default values
        self.operatorCombo.addItems({'ikke verdi', '>', '<', '>=', '<=', '=', '!='})
        self.operatorCombo.setCurrentIndex(-1)
        
#        deativating  combobox when starting
#        self.egenskapBox.setEnabled(False)
        self.operatorCombo.setEnabled(False)
        self.verdiField.setEnabled(False)
        
#        deactivating some UI components
        self.searchObjectBtn.setEnabled(False)
        self.visKartCheck.setEnabled(False)
        
#        autocompletion for nvdb field
        listObjectNames = self.fixNVDBObjects()
        self.setCompleterNVDBObjects(listObjectNames)
        
#        autocompletion for fylke field
        listOfCounties = self.fixFylkeObjects()
        self.setCompleterFylkeObjects(listOfCounties)
        
#        autocompletion for kommune field
        listOfCommunities = self.fixCommunityObjects()
        self.setCompleterCommunityObjects(listOfCommunities)
                
#        connecting signals and slots

#        very important to fecth kommuner when field fylke change
        self.fylkeField.editingFinished.connect(self.checkComunitiesInCounty)
        
        self.searchObjectBtn.clicked.connect(self.searchObj)
        
#        when vis i kart checkbox active then
        self.visKartCheck.clicked.connect(self.onVisIKart)
#        noen egenskap i UI skal være not enable til user skriver input
        self.nvdbIdField.editingFinished.connect(self.onNvdbIdFieldEdited)
#        when an item in table widget is clicked then
        self.tableResult.itemClicked.connect(self.onItemClicked)
        
#        when egenskap box change current item then 
        self.egenskapBox.currentIndexChanged.connect(self.onEgenskapChanged)
        
#        when operator box change then
        self.operatorCombo.currentIndexChanged.connect(self.onOperatorChanged)
        
#        when filtering the search in real time
        self.filterByLineEdit.textChanged.connect(self.filter)
        
#        connecting signal to nvdbCheck
#        self.nvdbCheck.clicked.connect(self.onNVDBCheckChange)
        
#        rest of methods===============================
    def fixNVDBObjects(self):
        nvdbObjects = AreaGeoDataParser.fetchAllNvdbObjects()
        
        listObjectNames = []
        self.listOfnvdbObjects = {}
        
        for key, value in nvdbObjects.items():
            listObjectNames.append(key)
            self.listOfnvdbObjects[key] = value
            
        return listObjectNames
        
    def fixFylkeObjects(self):
        nvdbObjects = AreaGeoDataParser.counties()
        
        listOfCountiesNames = []
        self.listOfCounties = {}
        self.reversListOfCounties = {}
        
        for key, value in nvdbObjects.items():
            listOfCountiesNames.append(key)
            self.listOfCounties[key] = value
            self.reversListOfCounties[value] = key
            
        return listOfCountiesNames
        
    def fixCommunityObjects(self):
        nvdbObjects = AreaGeoDataParser.communities()
        
        listOfCommunities = []
        self.listOfCommunitiesObjects = {}
        self.reversListOfCommunities = {}
        
        for key, value in nvdbObjects.items():
            listOfCommunities.append(key)
            self.listOfCommunitiesObjects[key] = value
            self.reversListOfCommunities[value] = key
            
        return listOfCommunities
        
    def checkComunitiesInCounty(self):
        data = []
        if self.fylkeField.text() == '':
#            print('empty')
            data = self.fixCommunityObjects()
            self.setCompleterCommunityObjects(data)
        
        elif self.fylkeField.text() != '': 
            text = self.fylkeField.text()
            for key, value in AreaGeoDataParser.communitiesInCounties.items():
                if value == self.listOfCounties[text]:
                    data.append(key)
                
        self.setCompleterCommunityObjects(data)
                
    def setCompleterNVDBObjects(self, data):
        autoCompleter = QCompleter(data)
        autoCompleter.setCaseSensitivity(False)
        
        self.nvdbIdField.setCompleter(autoCompleter)
        
    def setCompleterFylkeObjects(self, data):
        autoCompleter = QCompleter(data)
        autoCompleter.setCaseSensitivity(False)
        
        self.fylkeField.setCompleter(autoCompleter)
        
    def setCompleterCommunityObjects(self, data):
        autoCompleter = QCompleter(data)
        autoCompleter.setCaseSensitivity(False)
        
        self.kommuneField.setCompleter(autoCompleter)
        
    def searchObj(self):
#        here search is prepared depending on which filters user wants

#        when searchObj execute then vis kart options is enabled and checked is falsed
        self.visKartCheck.setEnabled(True)
        self.visKartCheck.setChecked(False)
        
#        set real time filter enabled when search filter applied
        self.filterByLineEdit.setEnabled(True)
        
#        clear content before a new search
        self.tableResult.clear()
        
#        setting row count to 0 again
        self.tableResult.setRowCount(0)
            
        if self.nvdbIdField.text() != '':
            nvdbId = self.listOfnvdbObjects[self.nvdbIdField.text()]
            self.v = nvdbFagdata(int(nvdbId))
        
        if self.fylkeField.text() in self.listOfCounties:
            fylke = self.listOfCounties[self.fylkeField.text()]
            self.v.filter( { 'fylke': int(fylke) } )
        
        if self.kommuneField.text() in self.listOfCommunitiesObjects:
            kommune = self.listOfCommunitiesObjects[self.kommuneField.text()]
            self.v.filter( { 'kommune': int(kommune) } )
            
        if self.vegreferanseField.text() != '':
            self.v.filter( { 'vegsystemreferanse': self.vegreferanseField.text() } )
        
#        only if egenskapbox, operatorBox and verdi fields are populated then
        if self.egenskapBox.currentText() != '' and self.operatorCombo.currentText() != '' and self.verdiField.text() != '':

#            some aux variables
            egensk = self.listOfEgenskaper[self.egenskapBox.currentText()]
            egenskAndVerdi = ''
            
#            some aux variables
            key = self.verdiField.text()
            verdi = self.verdiField.text()
            operator = self.operatorCombo.currentText()

#            some type checks
            
            if self.verdierDictionary:
                verdi = self.verdierDictionary[key]
            
            if not self.verdierDictionary and AreaGeoDataParser.egenskapDataType() == 'Tall': #if datatype is integer
                verdi = int(verdi)
                
            if not self.verdierDictionary and AreaGeoDataParser.egenskapDataType() != 'Tall': #otherwise treat it like string
                verdi = "'" + verdi + "'"
            
            egenskAndVerdi = f"egenskap({egensk}){operator}{verdi}"
            
            self.v.filter( {'egenskap': egenskAndVerdi })
            
#            print(egenskAndVerdi)
            
#        retrieve data with applied filters
        data = self.v.to_records()
        
        objects = self.makeMyDataObjects(data)
        
        self.setObjectsToUI(objects)

        
    def makeMyDataObjects(self, data):
        listObjects = []
        
        for element in data:
            for e in enumerate(element):
                key = e[1]
                obj = { key: element[key] }
                        
                listObjects.append(obj)
          
        return listObjects
        
    def onVisIKart(self, checked):
        if checked:
            self.v.refresh()
            nvdbsok2qgis(self.v)
        
        else:
            self.removeActiveLayers()
            
    def onNvdbIdFieldEdited(self):
        self.searchObjectBtn.setEnabled(True)
        
        #        setting list of agenskaper objects
        self.listOfEgenskaper = {}
        
#        clean egenskaper combobox anyway
        self.egenskapBox.clear()
        
        if self.listOfEgenskaper:
            self.listOfEgenskaper.clear() #cleaning before use in case of re-use
        
        egenskaper = AreaGeoDataParser.egenskaper(self.listOfnvdbObjects[self.nvdbIdField.text()])
        
        for key, value in egenskaper.items():
            self.egenskapBox.addItem(key)
            self.listOfEgenskaper[key] = value
        
        self.egenskapBox.addItem('ikke verdi') #adding aditional value to combo
        
#        removing layres just in case there are some actives
        self.removeActiveLayers()
        
    def setObjectsToUI(self, objects):
        items = []
        row = 0
        
#        parsing columns for adding to UI
        columns = self.parseHeaders(objects)
        index = self.indexHaders(columns)
        
        self.tableResult.setColumnCount(len(columns))
        self.tableResult.setHorizontalHeaderLabels(columns)
        
        for object in objects:
            for obj in enumerate(object):
                for idx in index:
                    if obj[1] == idx['header']:
                        
                        if obj[1] == 'fylke': #if header is fylke, then use name isntead of fylke number
                            numFylke = object[obj[1]]
                            nameFylke = self.reversListOfCounties[numFylke]
                            object[obj[1]] = nameFylke
                            
                        if obj[1] == 'kommune':  #if header is kommune, then use name isntead of kommune number
                            numKommune = object[obj[1]]
                            nameKommune = self.reversListOfCommunities[numKommune]
                            object[obj[1]] = nameKommune
                            
#                        if int(idx['index']) % 26 == 0:
#                        if obj[1] == 'geometri':
#                            row = row + 1
                        
                        self.tableResult.setRowCount(row+1)
                        newItem = QTableWidgetItem(str(object[obj[1]]))
                        self.tableResult.setItem(row, int(idx['index']), newItem)
                        
                        if obj[1] == 'geometri':
                            row = row + 1
                    
            
    def parseHeaders(self, objects):
        headers = []
        validHeaders =[]
        
        for obj in objects:
            if obj in headers:
                break
            headers.append(obj)
                
        for data in headers:
            for key in enumerate(data):
                validHeaders.append(key[1])
            
        return validHeaders
        
    def indexHaders(self, headers):
        list = []
        counter = 0
        
        for header in headers:
            index = {
            'index': counter,
            'header': header
            }
            
            counter = counter + 1
            
            list.append(index)
            
        return list
    
    def onItemClicked(self, item):
        data = self.substractItemData()
        
        self.copyNvdbId.setText(data['nvdbId'])
        self.copyVegRef.setText(data['vref'])
                
    def substractItemData(self):
        row = self.tableResult.currentRow()
        nvdbId = 0
        vref = ''
        
        for column in range(0, self.tableResult.columnCount()):
            itemColumHeader = self.tableResult.horizontalHeaderItem(column)
            
            if itemColumHeader.text() == 'nvdbId':
                resultNvdbId = self.tableResult.item(self.tableResult.currentRow(), column)
                nvdbId = resultNvdbId.text()
                
            elif itemColumHeader.text() == 'vref':
                resultVref = self.tableResult.item(self.tableResult.currentRow(), column)
                vref = resultVref.text()
                
        return {'nvdbId': nvdbId, 'vref': vref}
        
    def onEgenskapChanged(self):
        index = self.egenskapBox.currentIndex()
        
        if self.egenskapBox.itemText(index) != 'ikke verdi':
#            fetch sub egenskaper for better autocompletoin in verdi field
            self.subEgenskaper()
                
            self.operatorCombo.setEnabled(True)
            
        else:
            idx = self.operatorCombo.findText('ikke verdi')
            self.operatorCombo.setCurrentIndex(idx) #on each iteration onOperatorChange method is also called
            self.operatorCombo.setEnabled(False)
#        self.verdiField.setEnabled(True)
        
    def onOperatorChanged(self):
        if self.operatorCombo.currentText() == 'ikke verdi':
            self.verdiField.clear()
            self.verdiField.setEnabled(False)
            self.operatorCombo.setEnabled(False)
            
        else:
            self.verdiField.setEnabled(True)
#            when operator is selected then we want auto-completion to verdie field
#            self.subEgenskaper()
            
    def removeActiveLayers(self):
        names = [layer.name() for layer in QgsProject.instance().mapLayers().values()]
        
        for name in names:
            if name != 'OpenStreetMap':
                self.removeL(name)
            
    def subEgenskaper(self):
        nvdbId = self.listOfnvdbObjects[self.nvdbIdField.text()]
        especificEgenskap = self.egenskapBox.currentText()
        
        verdier = AreaGeoDataParser.especificEgenskaper(nvdbId, especificEgenskap)
        
        self.verdierDictionary = {}
        verdierList = []
        
#        cleaning verdierDictionary in case of already data in it
        if self.verdierDictionary:
            self.verdierDictionary.clear()
        
#        loop through list of verdier and set the auto-completion to verdi field in UI
        for key, value in verdier.items():
            verdierList.append(str(key))
            
            self.verdierDictionary[str(key)] = value #key should be string types
            
        self.setCompleterVerdierObjects(verdierList)
#        print(self.verdierDictionary)
        
    def setCompleterVerdierObjects(self, data):
        autoCompleter = QCompleter(data)
        autoCompleter.setCaseSensitivity(False)
        
        self.verdiField.setCompleter(autoCompleter)
        
    def onNVDBCheckChange(self, checked):
#            setting newlabel name to nvdbIdLabel and nvdbCheck

        if checked:
            self.nvdbCheck.setText('Objekt Navn')
            self.nvdbIdLabel.setText( self.nvdbCheck.text())
        
        else:
            self.nvdbCheck.setText('Objekt ID')
            self.nvdbIdLabel.setText( self.nvdbCheck.text())
            
    def filter(self, filter_text):
        for i in range(self.tableResult.rowCount()):
            for j in range(self.tableResult.columnCount()):
                item = self.tableResult.item(i, j)
                anotherText = item.text()
                match = filter_text.lower() not in anotherText.lower()
                self.tableResult.setRowHidden(i, match)
                if not match:
                    break
                    
    def removeL(self, name):
        qinst = QgsProject.instance()
        qinst.removeMapLayer(qinst.mapLayersByName(name)[0].id())
        
        iface.mapCanvas().refresh()
